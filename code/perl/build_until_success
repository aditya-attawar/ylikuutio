#!/usr/bin/env perl

# usage:
# build_until_success <build_dir> <CMakeLists.txt_dir>

use strict;
use warnings;
use 5.10.1;

use autodie;

use Cwd;            # cwd()
use Cwd 'abs_path'; # abs_path

use File::Temp qw/tempfile/; # tempfile

use Capture::Tiny 'capture_merged'; # capture_merged (to get both STDOUT and STDERR output).

use List::MoreUtils qw(any uniq); # uniq

my $n_args = $#ARGV + 1; # number of command line argumenst.

my $error_code_for_no_arguments = 1;
my $error_code_for_only_one_argument = 2;
my $error_code_for_more_than_two_argument = 3;

if ($n_args == 0)
{
    printf("Error: No command line arguments given!\n");
    printf("syntax: build_until_success <build_dir> <CMakeLists.txt_dir>\n");
    exit($error_code_for_no_arguments);
}
if ($n_args == 1)
{
    printf("Error: Only 1 command line argument given!\n");
    printf("syntax: build_until_success <build_dir> <CMakeLists.txt_dir>\n");
    exit($error_code_for_only_one_argument);
}
if ($n_args > 2)
{
    printf("Error: More than 2 command line arguments given!\n");
    printf("syntax: build_until_success <build_dir> <CMakeLists.txt_dir>\n");
    exit($error_code_for_more_than_two_argument);
}

# OK, we have exactly 2 command line arguments.
# The first is the build directory.

my $build_dir = $ARGV[0];
$build_dir = File::Spec->rel2abs($build_dir);                       # convert the directory to absolute.

my $cmakelists_txt_dir = $ARGV[1];
$cmakelists_txt_dir = File::Spec->rel2abs($cmakelists_txt_dir);     # convert the directory to absolute.

my ($volume, $script_dir, $file) = File::Spec->splitpath(__FILE__); # get directory of this script.
$script_dir = File::Spec->rel2abs($script_dir);                     # convert the directory to absolute.

printf("The script directory is %s\n", $script_dir);

my $current_dir = cwd();       # current directory.
printf("The current directory is %s\n", $current_dir);

my @make_with_args;            # arguments for `system`.
my $return_value;              # `make` return value.
my $output_fh;                 # `make` output file handle.
my $output_filename;           # `make` output file.

my $keep_building = 1;         # 0: do not keep building, 1: keep building.
my $build_attempt_count = 0;   # count of build attempts so far.

my @global_targets;
my @source_files;
my @duplicate_declarations;

my $result_files_fh;           # `make` output file handle.
my $result_files_filename;     # `make` output file.

my $result_source_file;
my $header_file;

my $action; # for testing: read user input.

while ($keep_building)
{
    $build_attempt_count++;
    my $timestamp_string = localtime; # get timestamp into `timestamp_array`.

    printf("Start of build attempt %d at %s\n", $build_attempt_count, $timestamp_string);

    chdir($build_dir);                # change to build directory.
    (undef, $output_filename) = tempfile("make_output_build_'${build_attempt_count}_XXXXXX", OPEN => 0, UNLINK => 0, DIR => $script_dir); # generate random
    open($output_fh, '>', $output_filename) or die "Can't open > $output_filename: $!";

    # execute `make`.
    print $output_fh capture_merged { system('make') };

    if ($? == -1)
    {
        printf("Failed to execute: $!\n");
        close($output_fh) or warn "Error closing > $output_filename";
        break;
    }

    close($output_fh) or warn "Error closing > $output_filename";
    open($output_fh, '<', $output_filename) or die "Can't open < $output_filename: $!";

    while (my $row = <$output_fh>)
    {
        chomp $row;

        my $undefined_reference_to_regex = ': undefined reference to `([^\']*)';
        if ($row =~ $undefined_reference_to_regex)
        {
            # print "$row\n"; # print make output
            my $function_reference = $1;
            # printf("Function reference: %s\n", $function_reference);

            # attempt to find the file[s] containing the function reference.

            my $class_function_regex = '([a-zA-Z0-9_]+)::(~|)[a-zA-Z0-9_]+';
            my $regular_function_regex = '([a-zA-Z0-9_]+)\(';

            my $global_target;

            if ($function_reference =~ $class_function_regex)
            {
                my $global_target = $1;
                # printf("Reference to class: %s\n", $global_target);
                push @global_targets, $global_target;
            }
            elsif ($function_reference =~ $regular_function_regex)
            {
                my $global_target = $1;
                # printf("Reference to regular function: %s\n", $global_target);
                push @global_targets, $global_target;
            }
        }
    }
    close($output_fh) or warn "Error closing < $output_filename";

    $return_value = ($? >> 8); # get the exit status of the command.

    if ($return_value == 0)
    {
        printf("Build attempt %d at %s was successful!\n", $build_attempt_count, $timestamp_string);
        last;
    }

    # Remove duplicates of `@global_targets`.
    my @filtered_global_targets = uniq(@global_targets);

    # Sort `@filtered_global_targets`.
    my @filtered_and_sorted_global_targets = sort @filtered_global_targets;

    # print "Global targets in alphabetical order:\n";
    # print join("\n", @filtered_and_sorted_global_targets) . "\n";

    chdir($cmakelists_txt_dir); # change to CMakeLists.txt directory.

    # Loop through `@filtered_and_sorted_global_targets` and find the file where they are located.

    foreach (@filtered_and_sorted_global_targets)
    {
        # current target is in `$_`.
        (undef, $result_files_filename) = tempfile("result_files_'${build_attempt_count}_XXXXXX", OPEN => 0, UNLINK => 0, DIR => $script_dir); # generate random
        open($result_files_fh, '>', $result_files_filename) or die "Can't open > $result_files_filename $!";

        # execute `global`.
        print $result_files_fh capture_merged { system("global $_") };

        if ($? == -1)
        {
            printf("Failed to execute: $!\n");
            close($result_files_fh) or warn "Error closing > $result_files_filename";
            break;
        }

        close($result_files_fh) or warn "Error closing > $result_files_filename";
        open($result_files_fh, '<', $result_files_filename) or die "Can't open < $result_files_filename $!";

        while (my $result_source_file = <$result_files_fh>)
        {
            chomp $result_source_file;
            if ($result_source_file ne '0') # for some reason there appears filename `'0'`.
            {
                printf("Target %s is located in %s\n", $_, $result_source_file);
                push(@source_files, $result_source_file);

                $header_file = $result_source_file;
                $header_file =~ s/\.(c|cpp)$/.h/g;

                if (-f $header_file)
                {
                    push(@source_files, $header_file);
                }
            }
        }
    }

    # Remove duplicates of `@source_files`.
    my @filtered_source_files = uniq(@source_files);

    # Sort `@filtered_source_files`.
    my @filtered_and_sorted_source_files = sort @filtered_source_files;

    my $source_files_string = join("\n", @filtered_and_sorted_source_files) . "\n";
    printf("Source files in targets in alphabetical order:\n%s\n", $source_files_string);

    # Do regex replace in `CMakeLists.txt`.
    my $cmakelists_txt_filename = 'CMakeLists.txt';
    my $new_cmakelists_txt_filename = 'new' . $cmakelists_txt_filename;
    my $build_until_success_source_files_end_regex = 'BUILD_UNTIL_SUCCESS_SOURCE_FILES_END';
    open my $input, '<', $cmakelists_txt_filename or die "can't open $cmakelists_txt_filename: $!";
    open my $output, '>', $new_cmakelists_txt_filename or die "can't open $new_cmakelists_txt_filename: $!";

    while (<$input>)
    {
        if ($_ =~ $build_until_success_source_files_end_regex)
        {
            print $output "Build attempt " . $build_attempt_count . " at " . $timestamp_string . "\n";
            print $output $source_files_string;
        }
        print $output $_;
    }

    close $input;
    close $output;

    while (1)  # for testing: read user input.
    {
        printf "break/continue: ";
        $action = <STDIN>; # read user input.
        chomp $action;     # get rid of newline at the end of the string.

        if ($action eq "break")
        {
            $keep_building = 0;
            last;
        }
        if ($action eq "continue")
        {
            last;
        }
    }
}

# OK, the build was successful.
chdir($current_dir);
